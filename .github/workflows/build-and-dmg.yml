name: Build macOS app and produce DMG

permissions:
  contents: write

on:
  push:
    branches: ["main", "master"]
    tags: ["v*"]
  pull_request:
    branches: ["main"]
  workflow_dispatch: {}

jobs:
  build-and-dmg:
    name: Build and create DMG
    runs-on: macos-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Cache Xcode DerivedData
        uses: actions/cache@v4
        with:
          path: |
            build/DerivedData
            ~/Library/Developer/Xcode/DerivedData
          key: deriveddata-${{ runner.os }}-${{ hashFiles('**/SwiftBmo.xcodeproj/project.pbxproj') }}
          restore-keys: |
            deriveddata-${{ runner.os }}-

      - name: Ensure build script is executable
        run: chmod +x scripts/build_and_dmg.sh

      - name: Install signing certificate (optional)
        run: |
          set -euo pipefail
          # runtime check: if secret is empty, skip this step
          if [[ -z "${{ secrets.APP_CERT_P12_BASE64 }}" ]]; then
            echo "APP_CERT_P12_BASE64 not set - skipping signing certificate installation"
            exit 0
          fi
          echo "Installing signing certificate into temporary keychain"

          # export secrets into environment variables for script use
          APP_CERT_P12_BASE64="${{ secrets.APP_CERT_P12_BASE64 }}"
          APP_CERT_P12_PASSWORD="${{ secrets.APP_CERT_P12_PASSWORD }}"

          # generate a random password for the temporary keychain
          KEYCHAIN_PASSWORD=$(python3 -c "import secrets; print(secrets.token_hex(16))")
          # create a unique keychain name to avoid collisions
          KEYCHAIN_NAME="ci-build-$(date +%s)-$RANDOM.keychain"

          # create keychain and set up
          security create-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_NAME"
          security set-keychain-settings -t 3600 -u "$KEYCHAIN_NAME"

          # decode base64 (support both GNU and BSD base64 options)
          P12_FILE="/tmp/signing_cert.p12"
          if ! (echo "$APP_CERT_P12_BASE64" | base64 --decode > "$P12_FILE" 2>/dev/null); then
            echo "$APP_CERT_P12_BASE64" | base64 -D > "$P12_FILE"
          fi

          # import p12 into the new keychain and allow codesign and security to access it
          security import "$P12_FILE" -k ~/Library/Keychains/$KEYCHAIN_NAME -P "$APP_CERT_P12_PASSWORD" -T /usr/bin/codesign -T /usr/bin/security || true

          # add the keychain to the search path
          EXISTING_KCS=$(security list-keychains -d user | tr -d '"')
          security list-keychains -d user -s ~/Library/Keychains/$KEYCHAIN_NAME $EXISTING_KCS

          # unlock and set partition list so codesign can use the private key non-interactively
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" ~/Library/Keychains/$KEYCHAIN_NAME
          security set-key-partition-list -S apple-tool:,apple: -s -k "$KEYCHAIN_PASSWORD" ~/Library/Keychains/$KEYCHAIN_NAME || true

          # expose variables for later cleanup
          echo "KEYCHAIN_NAME=$KEYCHAIN_NAME" >> "$GITHUB_ENV"
          echo "KEYCHAIN_PASSWORD=$KEYCHAIN_PASSWORD" >> "$GITHUB_ENV"

      - name: Install provisioning profile (optional)
        run: |
          set -euo pipefail
          # runtime check: skip if no provisioning profile secret provided
          if [[ -z "${{ secrets.PROV_PROFILE_BASE64 }}" ]]; then
            echo "PROV_PROFILE_BASE64 not set - skipping provisioning profile installation"
            exit 0
          fi
          PROV_PROFILE_BASE64="${{ secrets.PROV_PROFILE_BASE64 }}"
          echo "Installing provisioning profile (if provided)"
          mkdir -p ~/Library/MobileDevice/Provisioning\ Profiles
          PROFILE_TMP="/tmp/profile.mobileprovision"
          if ! (echo "$PROV_PROFILE_BASE64" | base64 --decode > "$PROFILE_TMP" 2>/dev/null); then
            echo "$PROV_PROFILE_BASE64" | base64 -D > "$PROFILE_TMP"
          fi
          # extract UUID from the provisioning profile using Python plistlib
          UUID=$(python3 -c "import plistlib,subprocess;data=subprocess.check_output(['security','cms','-D','-i','/tmp/profile.mobileprovision']);pl=plistlib.loads(data);print(pl.get('UUID',''))")
          if [[ -n "$UUID" ]]; then
            cp "$PROFILE_TMP" ~/Library/MobileDevice/Provisioning\ Profiles/${UUID}.mobileprovision
            echo "Installed provisioning profile: ${UUID}.mobileprovision"
          else
            echo "Could not extract UUID from provisioning profile; installing with generic name"
            cp "$PROFILE_TMP" ~/Library/MobileDevice/Provisioning\ Profiles/profile.mobileprovision
          fi

      - name: Show Xcode version
        run: xcodebuild -version

      - name: Update app version for tag
        if: startsWith(github.ref, 'refs/tags/')
        run: |
          VERSION=${GITHUB_REF_NAME#v}
          echo "Setting app version to $VERSION"
          plutil -replace CFBundleShortVersionString -string "$VERSION" SwiftBmo/Info.plist

      - name: Run build_and_dmg script
        id: build_script
        run: |
          set -euxo pipefail
          # create output dir under build so it can be cached/collected
          mkdir -p build/dist
          # Run the project's build script. Adjust scheme/config as needed.
          bash scripts/build_and_dmg.sh -s SwiftBmo -c Release -o build/dist --clean

      - name: List dist contents
        run: |
          echo "Dist contents:"
          ls -la build/dist || true
          echo "DerivedData products:"
          ls -la build/DerivedData/Build/Products || true

      - name: Detect generated DMG
        id: detect_dmg
        run: |
          set -euo pipefail
          DMG_PATH="build/dist/SwiftBmo.dmg"
          if [[ -f "$DMG_PATH" ]]; then
            echo "dmg=$DMG_PATH" >> "$GITHUB_OUTPUT"
            echo "DMG found: $DMG_PATH"
          else
            echo "dmg=" >> "$GITHUB_OUTPUT"
            echo "DMG not found"
          fi
        shell: bash

      - name: Upload DMG artifact
        uses: actions/upload-artifact@v4
        with:
          name: SwiftBmo-dmg
          path: build/dist/*.dmg

      - name: Upload .app artifact (zipped)
        if: always()
        run: |
          set -euo pipefail
          APP_ZIP="build/SwiftBmo-app.zip"
          # find first .app in DerivedData products
          FOUND_APP=$(find build/DerivedData/Build/Products -maxdepth 4 -type d -name "*.app" | head -n 1 || true)
          if [[ -n "$FOUND_APP" ]]; then
            echo "Found app: $FOUND_APP"
            ditto -c -k --sequesterRsrc --keepParent "$FOUND_APP" "$APP_ZIP"
            echo "Zipped app to $APP_ZIP"
            gh-actions-upload-artifact-helper() { echo; }
          else
            echo "No .app found to upload"
          fi
        shell: bash

      - name: Upload zipped .app artifact
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: SwiftBmo-app-zip
          path: build/SwiftBmo-app.zip

      - name: Create GitHub Release for tag
        if: ${{ startsWith(github.ref, 'refs/tags/') && steps.detect_dmg.outputs.dmg != '' }}
        id: create_release
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: ${{ github.ref_name }}
          release_name: Release ${{ github.ref_name }}
          body: "Automatic build + DMG generated by CI"
          draft: false
          prerelease: false

      - name: Upload DMG to GitHub Release
        if: ${{ startsWith(github.ref, 'refs/tags/') && steps.detect_dmg.outputs.dmg != '' }}
        uses: actions/upload-release-asset@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          upload_url: ${{ steps.create_release.outputs.upload_url }}
          asset_path: ${{ steps.detect_dmg.outputs.dmg }}
          asset_name: SwiftBmo.dmg
          asset_content_type: application/x-apple-diskimage

      - name: Remove temporary keychain (if created)
        run: |
          set -euo pipefail
          # KEYCHAIN_NAME is set via GITHUB_ENV at runtime by the import step.
          # Evaluate at runtime in the shell rather than in a workflow expression.
          if [[ -n "${KEYCHAIN_NAME:-}" ]]; then
            echo "Deleting temporary keychain: $KEYCHAIN_NAME"
            # ensure keychain is unlocked to allow deletion
            security unlock-keychain -p "${KEYCHAIN_PASSWORD:-}" ~/Library/Keychains/$KEYCHAIN_NAME || true
            security delete-keychain "$KEYCHAIN_NAME" || true
          else
            echo "No temporary keychain to delete"
          fi
        shell: bash

      - name: Cleanup potential secrets (placeholder)
        run: |
          echo "No secrets were added by this workflow. If you add signing artifacts (certs/profiles), remove them here."
        shell: bash

# Notes:
# - This workflow now supports optional CI code signing when you set secrets:
#     - APP_CERT_P12_BASE64: base64-encoded PKCS#12 (p12) certificate that contains the signing identity private key
#     - APP_CERT_P12_PASSWORD: password for the p12
#     - PROV_PROFILE_BASE64: (optional) base64-encoded provisioning profile (mainly for iOS, macOS rarely needs it)
# - The signing certificate is imported into a temporary keychain so it does not persist on the runner.
# - For notarization you still need App Store Connect API keys and an additional notarize step after DMG creation.
# - Keep your secrets safe and do not expose them in PRs from forks (GitHub prevents secrets in forked PRs by default).
